# Notes for Developing .NET API Projects
[Back](../README.md)

## Technology Stacks
Tech | Purpose | Link
---- | ---- | ----
PostgreSQL | Relational database management system | None
pgAdmin | GUI for managing PostgreSQL DB | None
Npgsql. EntityFrameworkCore. PostgreSQL | EF Core provider for PostgreSQL | None
AutoMapper | Object-object mapping | None






## Steps
1. Draw UML Class Diagram

2. Create tables in PostgreSQL

3. Create a .NET API codebase solution

4. Create entities corresponding to tables in DB

5. Create a DbContext class
    - __Example:__
    ```cs
    public class AppDbContext : DbContext
    {
        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }

        public DbSet<Book> Books { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Book>().ToTable("books");
            modelBuilder.Entity<Book>().HasKey(b => b.Id);
            modelBuilder.Entity<Book>().Property(b => b.Title).HasColumnName("title");
            modelBuilder.Entity<Book>().Property(b => b.Author).HasColumnName("author");
            modelBuilder.Entity<Book>().Property(b => b.PublishedDate).HasColumnName("published_date");
        }
    }
    ```

6. Install Nuget package Npgsql.EntityFrameworkCore.PostgreSQL

7. Register the DbContext class
    - Add connection string in __appsettings.json__
    ```json
    "ConnectionStrings": {
        "DefaultConnection": "Host=localhost;Port=123;Database=your_db;Username=postgres;Password=1234"
    }
    ```
    - Add dbcontext in __Program.cs__
    ```cs
    builder.Services.AddDbContext<AppDbContext>(options => options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));
    ```

8. Add a Generic Repository Layer
    - View more [generic repository and unit of work](https://learn.microsoft.com/en-us/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)
    - Should create both interface and its implementation class
    - Should use this generic get all method
    ```cs
    public virtual IEnumerable<TEntity> Get(
    Expression<Func<TEntity, bool>> filter = null,
    Func<IQueryable<TEntity>, IOrderedQueryable<TEntity>> orderBy = null,
    string includeProperties = "")
    ```
    - The code `Expression<Func<TEntity, bool>> filter` means the caller will provide a lambda expression based on the TEntity type, and this expression will return a Boolean value. For example, `student => student.LastName == "Smith"`
    - The code `Func<IQueryable<TEntity>, IOrderedQueryable<TEntity>> orderBy` also means the caller will provide a lambda expression. For example, `q => q.OrderBy(s => s.LastName)`

9. Add Unit of Work Interface and Implementation
    - All repositories of entities will be stored here.

10. Add DTOs classes for corresponding entity
    - Naming: Entity`Dto` for general purposes like receiving or updating entity.
    ```json
    {
        "href": "https://localhost:7222/api/areas/22e54b03-4b75-43c8-b6cb-e878361286aa",
        "key": "22e54b03-4b75-43c8-b6cb-e878361286aa",
        "name": "Test Container editing",
        "containerLevel": 1,
        "description": "This is a test container editing",
        "areaId": "e254843d-dda2-4061-989f-1c077230d0ea"
    }
    ```
    - Entity`CreateDto` for creating a new entity.

11. Add mapping profile using [automapper](https://automapper.org/)
    - Create `MappingProfile.cs`
    ```cs
    public class MappingProfile : Profile
    {
        public MappingProfile()
        {
            // Area entity
            CreateMap<Area, AreaDto>()
                .ForMember(d => d.Key, opt => opt.MapFrom(src => src.AreaId))
                .ForMember(d => d.Href, opt => opt.Ignore())
                .ReverseMap()
                .ForMember(d => d.CreatedDate, opt => opt.Ignore())
                .ForMember(d => d.UpdatedDate, opt => opt.Ignore());

            CreateMap<AreaCreateDto, Area>();
        }
    }
    ```
    - Register in `Program.cs`
    `builder.Services.AddAutoMapper(typeof(MappingProfile));`

12. Add a Service Layer
    - Check `DbUpdateConcurrencyException` when using `UPDATE` or `DELETE` methods in repository layer - [view more](https://learn.microsoft.com/en-us/ef/core/saving/concurrency?tabs=data-annotations)
    - Should use `uuid` data type to add an attribute for checking the error.
    - Code example
    ```cs
    modelBuilder.Entity<Book>(entity =>
    {
        // Required if not generated by scaffolding
        entity.Property(e => e.RowVersion)
              .IsRequired()
              .IsConcurrencyToken()
              .HasColumnName("row_version");
    });
    ```
    - One advantage of manually managing the concurrency token is that you can control precisely when it gets regenerated, to avoid needless concurrency conflicts. --> `Should NOT create auto-generated uuid for the tracking column in DB`.

13. Register all DI in `Program.cs`
    - `builder.Services.AddScoped<IAreaService, AreaService>();`

14. Create Controllers
    - Web API controllers should typically derive from ControllerBase rather from Controller. Controller derives from ControllerBase and adds support for views, so it's for handling web pages, not web API requests.
    - The `[ApiController]` attribute makes model validation errors automatically trigger an HTTP 400 response. [View more](https://learn.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-9.0#automatic-http-400-responses)